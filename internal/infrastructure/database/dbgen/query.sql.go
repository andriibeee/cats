// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package dbgen

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCat = `-- name: CreateCat :exec
INSERT INTO cats (
    id, name, experience, breed, salary
) VALUES (
             $1, $2, $3, $4, $5
         )
    ON CONFLICT (id) DO UPDATE
    SET name = $2,
        experience = $3,
        breed = $4,
        salary = $5
`

type CreateCatParams struct {
	ID         pgtype.UUID
	Name       string
	Experience int32
	Breed      string
	Salary     int32
}

func (q *Queries) CreateCat(ctx context.Context, arg CreateCatParams) error {
	_, err := q.db.Exec(ctx, createCat,
		arg.ID,
		arg.Name,
		arg.Experience,
		arg.Breed,
		arg.Salary,
	)
	return err
}

const createMission = `-- name: CreateMission :exec
INSERT INTO missions (
    id, targets, assignee_id, complete
) VALUES (
             $1, $2, $3, $4
         )
    ON CONFLICT (id) DO UPDATE
                            SET targets = $2,
                            assignee_id = $3,
                            complete = $4
`

type CreateMissionParams struct {
	ID         pgtype.UUID
	Targets    []byte
	AssigneeID pgtype.UUID
	Complete   bool
}

func (q *Queries) CreateMission(ctx context.Context, arg CreateMissionParams) error {
	_, err := q.db.Exec(ctx, createMission,
		arg.ID,
		arg.Targets,
		arg.AssigneeID,
		arg.Complete,
	)
	return err
}

const deleteCat = `-- name: DeleteCat :exec
DELETE FROM cats
WHERE id = $1
`

func (q *Queries) DeleteCat(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteCat, id)
	return err
}

const deleteMission = `-- name: DeleteMission :exec
DELETE FROM missions
WHERE id = $1
`

func (q *Queries) DeleteMission(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteMission, id)
	return err
}

const getCat = `-- name: GetCat :one
SELECT id, name, experience, breed, salary FROM cats
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetCat(ctx context.Context, id pgtype.UUID) (Cat, error) {
	row := q.db.QueryRow(ctx, getCat, id)
	var i Cat
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Experience,
		&i.Breed,
		&i.Salary,
	)
	return i, err
}

const getCats = `-- name: GetCats :many
SELECT id, name, experience, breed, salary FROM cats
`

func (q *Queries) GetCats(ctx context.Context) ([]Cat, error) {
	rows, err := q.db.Query(ctx, getCats)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Cat
	for rows.Next() {
		var i Cat
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Experience,
			&i.Breed,
			&i.Salary,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMission = `-- name: GetMission :one
SELECT
    missions.id, missions.targets, missions.assignee_id, missions.complete,
    cats.name AS assignee_name, cats.experience AS assignee_experience, cats.breed AS assignee_breed,
    cats.salary AS assignee_salary
FROM missions
LEFT JOIN cats
ON missions.assignee_id  = cats.id
WHERE missions.id = $1
LIMIT 1
`

type GetMissionRow struct {
	ID                 pgtype.UUID
	Targets            []byte
	AssigneeID         pgtype.UUID
	Complete           bool
	AssigneeName       pgtype.Text
	AssigneeExperience pgtype.Int4
	AssigneeBreed      pgtype.Text
	AssigneeSalary     pgtype.Int4
}

func (q *Queries) GetMission(ctx context.Context, id pgtype.UUID) (GetMissionRow, error) {
	row := q.db.QueryRow(ctx, getMission, id)
	var i GetMissionRow
	err := row.Scan(
		&i.ID,
		&i.Targets,
		&i.AssigneeID,
		&i.Complete,
		&i.AssigneeName,
		&i.AssigneeExperience,
		&i.AssigneeBreed,
		&i.AssigneeSalary,
	)
	return i, err
}

const getMissions = `-- name: GetMissions :many
SELECT
    missions.id, missions.targets, missions.assignee_id, missions.complete,
    cats.name AS assignee_name, cats.experience AS assignee_experience, cats.breed AS assignee_breed,
    cats.salary AS assignee_salary
FROM missions
LEFT JOIN cats ON missions.assignee_id  = cats.id
`

type GetMissionsRow struct {
	ID                 pgtype.UUID
	Targets            []byte
	AssigneeID         pgtype.UUID
	Complete           bool
	AssigneeName       pgtype.Text
	AssigneeExperience pgtype.Int4
	AssigneeBreed      pgtype.Text
	AssigneeSalary     pgtype.Int4
}

func (q *Queries) GetMissions(ctx context.Context) ([]GetMissionsRow, error) {
	rows, err := q.db.Query(ctx, getMissions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetMissionsRow
	for rows.Next() {
		var i GetMissionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Targets,
			&i.AssigneeID,
			&i.Complete,
			&i.AssigneeName,
			&i.AssigneeExperience,
			&i.AssigneeBreed,
			&i.AssigneeSalary,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCat = `-- name: UpdateCat :exec
UPDATE cats
set name = $2,
    experience = $3,
    breed = $4,
    salary = $5
WHERE id = $1
`

type UpdateCatParams struct {
	ID         pgtype.UUID
	Name       string
	Experience int32
	Breed      string
	Salary     int32
}

func (q *Queries) UpdateCat(ctx context.Context, arg UpdateCatParams) error {
	_, err := q.db.Exec(ctx, updateCat,
		arg.ID,
		arg.Name,
		arg.Experience,
		arg.Breed,
		arg.Salary,
	)
	return err
}

const updateMission = `-- name: UpdateMission :exec
UPDATE missions
set targets = $2,
    assignee_id = $3,
    complete = $4
WHERE id = $1
`

type UpdateMissionParams struct {
	ID         pgtype.UUID
	Targets    []byte
	AssigneeID pgtype.UUID
	Complete   bool
}

func (q *Queries) UpdateMission(ctx context.Context, arg UpdateMissionParams) error {
	_, err := q.db.Exec(ctx, updateMission,
		arg.ID,
		arg.Targets,
		arg.AssigneeID,
		arg.Complete,
	)
	return err
}
